package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path"
	"strings"

	"gopkg.in/yaml.v2"
)

type Config struct {
	ReposDirectory string `yaml:"repos_directory"`
	EnvFilename    string `yaml:"env_file"`
	RcFilename     string `yaml:"rc_file"`
}

type Command struct {
	Program string   `yaml:"program"`
	Args    []string `yaml:"args"`
}

type DotFile struct {
	AbsoluteSourceDirectives []string `yaml:"absolute_source_directives"`
	RelativeSourceDirectives []string `yaml:"relative_source_directives"`
	AbsolutePaths            []string `yaml:"absolute_paths"`
	RelativePaths            []string `yaml:"relative_paths"`
}

type GithubDependency struct {
	Command         string    `yaml:"command"`
	Repo            string    `yaml:"repo"`
	InstallCommands []Command `yaml:"install_commands"`
	Env             DotFile   `yaml:".env"`
	Rc              DotFile   `yaml:".rc"`
	Groups          GroupList `yaml:"groups"`
}

type Dependencies struct {
	Config             Config             `yaml:"config"`
	GithubDependencies []GithubDependency `yaml:"github"`
}

type GroupList []string

func (gl *GroupList) String() string {
	if gl != nil {
		strings.Join(*gl, ",")
	}
	return ""
}

func (gl *GroupList) Set(group string) error {
	*gl = append(*gl, group)
	return nil
}

// TODO: push to repo, include instructions
// TODO: ensure existence of repos directory

func Usage() {
	fmt.Printf("Usage: %s [OPTIONS] config-filename\n", os.Args[0])
	flag.PrintDefaults()
}

func main() {
	flag.Usage = Usage

	groupList := GroupList{"default"}
	flag.Var(&groupList, "group", "Group to include in setup. List the flag multiple times for multiple groups. 'default' group is always included.")
	flag.Parse()

	if len(flag.Args()) != 1 {
		log.Fatal("Unexpected input. Must take one and only one config file name as argument.")
	}

	configFilename := flag.Arg(0)

	yamlBytes, err := os.ReadFile(configFilename)

	if err != nil {
		log.Fatal(err)
	}

	var dependencies Dependencies
	yaml.Unmarshal(yamlBytes, &dependencies)

	config := dependencies.Config

	assertString(config.ReposDirectory)
	config.ReposDirectory = strings.TrimRight(os.ExpandEnv(config.ReposDirectory), "/")

	fmt.Println(config.ReposDirectory)

	assertString(config.EnvFilename)
	assertString(config.RcFilename)

	createOrTruncateAutoGeneratedFile(config.EnvFilename)
	createOrTruncateAutoGeneratedFile(config.RcFilename)

	for _, dependency := range dependencies.GithubDependencies {
		if hasAMatchingGroup(groupList, dependency.Groups) {
			ensureGithubInstallation(config, dependency)
		}
	}
}

func ensureGithubInstallation(config Config, dependency GithubDependency) {
	fmt.Println("Ensuring installation for", dependency.Command)
	repoPath := config.ReposDirectory + "/" + path.Base(dependency.Repo)

	if commandExists(dependency.Command) {
		fmt.Println("Command already exists.")
	} else if dirExists(repoPath) {
		fmt.Println("Repository is already cloned.")
	} else {
		fmt.Println("Cloning repository")
		cloneRepo(config.ReposDirectory, dependency)
	}

	appendDotFile(config.EnvFilename, dependency.Env, repoPath)
	appendDotFile(config.RcFilename, dependency.Rc, repoPath)
}

func cloneRepo(repoDirectory string, dependency GithubDependency) {
	clone := exec.Command("git", "clone", "git@github.com:"+dependency.Repo+".git")
	clone.Dir = repoDirectory
	clone.Stdout = os.Stdout
	clone.Stderr = os.Stderr
	err := clone.Run()

	if err != nil {
		log.Fatal(err)
	}
}

func dirExists(path string) bool {
	_, err := os.Stat(path)
	return !os.IsNotExist(err)
}

func commandExists(command string) bool {
	_, err := exec.LookPath(command)
	return err == nil
}

func assertString(s string) {
	if s == "" {
		log.Fatal(s + " must be provided.")
	}
}

func appendDotFile(filename string, dotfile DotFile, relativeBase string) {
	f, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	defer f.Close()

	if err != nil {
		log.Fatal(err)
	}

	for _, path := range dotfile.RelativePaths {
		fmt.Fprintln(f, "export PATH=\"$PATH:"+relativeBase+"/"+path+"\"")
	}

	for _, path := range dotfile.AbsolutePaths {
		fmt.Fprintln(f, "export PATH=\"$PATH:"+path+"\"")
	}

	for _, path := range dotfile.RelativeSourceDirectives {
		fmt.Fprintln(f, "source "+relativeBase+"/"+path)
	}

	for _, path := range dotfile.AbsoluteSourceDirectives {
		fmt.Fprintln(f, "source "+path)
	}
}

func createOrTruncateAutoGeneratedFile(filename string) {
	f, err := os.Create(filename)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Fprintln(f, "# *******     AUTOGENERATED FILE     *******")
	fmt.Fprintln(f, "# ----- created by dsetup. DO NOT EDIT -----")
	fmt.Fprintln(f, "")
}

func hasAMatchingGroup(includedGroups GroupList, dependencyGroups GroupList) bool {
	for _, includedGroup := range includedGroups {
		for _, dependencyGroup := range dependencyGroups {
			if dependencyGroup == includedGroup {
				return true
			}
		}
	}
	return false
}
